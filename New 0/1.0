from telethon import TelegramClient, events
import re

api_id = ''   # Your application ID
api_hash = ''  # Your application hash
my_channel_id = '@KotikiOKotiki'  # Your channel ID
channels = ['@koshki7', '@samorazvitie_kotiki', '@lovemeowcats', '@meow_kotiki', '@catslovemeow', '@cats_cats', '@vkcatism', '@TEST_TESTBEST', '@TEST_BESTTEST']


client = TelegramClient('myGrab', api_id, api_hash)
print("GRAB - Started")

# Функция для замены упоминаний и отправки сообщения в канал
async def send_to_channel(message, file=None):
    # Проверка на наличие упоминаний
    mentions = re.findall(r'@\w+', message)
    if not mentions:
        # Замена упоминаний в сообщении
        for channel in channels:
            message = re.sub(rf'(?<!\w){channel}(?!\w)', my_channel_id[1:], message)
        
        # Проверка на наличие ссылок в сообщении
        contains_link = re.search(r'http[s]?://\S+', message)
        
        # Проверка на наличие запрещенных ссылок
        contains_blocked_link = re.search(r'(t\.me/free_piarr|vk\.me/kotikineprotiv)', message)
        
        # Отправка сообщения в канал, если нет ссылок и нет запрещенных ссылок
        if not contains_link and not contains_blocked_link:
            if file:
                await client.send_message(my_channel_id, file=file, message=message)
                print("Сообщение с медиа отправлено:", message)
            else:
                await client.send_message(my_channel_id, message=message)
                print("Текстовое сообщение отправлено:", message)
        else:
            print("Сообщение не отправлено из-за наличия ссылок:", message)
    else:
        print("Упоминания заменены и отправлены:", message)
        # Замена упоминаний на @KotikiOKotiki и отправка сообщения
        for mention in mentions:
            message = message.replace(mention, my_channel_id)
        if file:
            await client.send_message(my_channel_id, file=file, message=message)
        else:
            await client.send_message(my_channel_id, message=message)

@client.on(events.NewMessage(chats=channels))
async def my_event_handler(event):
    if event.message and not event.message.grouped_id:
        # Отправка сообщения в канал с замененными упоминаниями и медиафайлами, если они есть
        await send_to_channel(event.message.text, file=event.message.media)

processed_first_update = False

@client.on(events.Album(chats=channels))
async def handler(event):
    global processed_first_update
    if not processed_first_update:
        processed_first_update = True
        return
    
    # Получение сообщения из альбома
    message = event.original_update.message.message
    
    # Проверка на наличие ссылок в сообщении
    contains_link = re.search(r'http[s]?://\S+', message)
    
    # Проверка на наличие запрещенных ссылок
    contains_blocked_link = re.search(r'(t\.me/free_piarr|vk\.me/kotikineprotiv)', message)
    
    # Отправка альбома в канал, если нет ссылок и нет запрещенных ссылок
    if not contains_link and not contains_blocked_link:
        await send_to_channel(message, file=event.messages)
    else:
        print("Альбом не отправлен из-за наличия ссылок:", message)

client.start()
client.run_until_disconnected()
